\section{Solución desarrollada}
Durante el proyecto se desarrollo una solución al problema de exploración
multirobot. Esto requiere la soluciones para una gran cantidad de problemas
relacionados a diversos aspectos de la exploración multirobot, este proyecto se
concentrara en algunos de ellos.

% se a partir de la información sensorial de los
El problema construir un mapa de forma cooperativa robots se soluciona construyendo una grilla de ocupación con
el algoritmo de actualización presentado en \cite{stachniss2009robotic}.

% Se presenta una solución para las dos partes asociadas al

Con respecto al problema de asignación de tareas (sección
\ref{sec:exploracion}) se presentan soluciones para cada una de sus partes.
Para la identificación de objetivos se propone una técnica novedosa que
determina \todo{FEDE: estaria bueno aca poner un adjetivo que resuma como es el
algorimo que desarrolle. De forma: determinista, geometrica, otro?} como
objetivos a un subconjunto de los puntos fronterizos. Con respecto a la
asignación de objetivos a robots, esta se resuelve de forma coordinada
aplicando una variante de lo presentado en la sección \ref{subsec:wurmCoord}.

La asignación requiere de la construcción de un mapa topológico, para esto se
implementa la técnica descrita en la sección \ref{subsec:mapaTopGVD},
construyendo el GVD de forma incremental con una variante del algoritmo
\emph{brushfire dinámico} (sección \ref{subsec:constGVDInc}).

Luego de asignado a un objetivo el robot deberá llegar hasta el, para esto es
necesario solucionar el este problema de planificación. La solución desarrollada 
aplica las ideas de planificación jerárquica presentadas en la sección
\ref{subsec:mapas}, con el motivo de permitir una planificación eficiente sin
resultar en caminos innecesariamente largos.


\section{Principales aportes}

Propuesta y estudio de un algoritmo novedoso para identificación de objetivos basado en la simplificacion de fronteras.% que no se basa en un algoritmo de clasificación no supervisada (p.e. K-Means).

Estudiar la coordinación que se propone en \cite{wurm2008coordinated} utilizando una construcción incremental del GVD.

Propuesta y estudio de un algoritmo de construcción incremental de un GVD basado en \emph{brushfire dinámico} según se describe en \cite{Lau2013} cambiando principalmente la forma de determinar las celdas pertenecientes al GVD.

Adicionalmente se estudia un aspecto critico que no esta explicito en el estado del arte\todo{FEDE: Kalra se ve que el mapa para entorno abierto es consistente con esta tecnica, en el codigo de lau tambien. Pero no se hace referancia a esto}, el problema asociado a como se tratan las celdas de estado desconocido en la construcción del GVD. Para este problema se comentan posibles alternativas, pasando por la que esta presente en el estado del arte y una técnica novedosa que permite una mayor eficiencia.

% Proponer un algoritmo novedoso para la simplificacion de conjuntos de fronteras que ... (no se que poner aca, pongo)
% Estudiar la coordinacion propuesta une wurm utilizando un  GVD incremental ya que de lo contrario no es escalable.
% Y que adicionalemtente se implemento una construiccion de GVD novedosa que basa su construiccion en sources y pseudosources (la idea intuitiva pero considerando los potenciales problemas de discretizacion)
% Llamado de atencion al problema de conectividad de un GVD al explorar donde en un mapa no solo hay obtaculos y celdas libres si no que tambien hay celdas desconocidas, las cuales no se consideran en los articulos del estado del arte. Estos se asume (no se explicita pero en Kalra se ve que el mapa para entorno abierto es consistente con esta tecnica, en el codigo de lau tambien) que implementan la tecnica de "los limites de mi mapa son obstaculos" y lo desconocido es libre. En este trabajo se propone una tecnica novedosa que soluciona este problema de forma mas eficiente evitando procesar todo el espacio desconocido mientras se va explorando.

\section{Hipótesis de trabajo}
La solución desarrollada tomara las siguientes hipótesis de trabajo.
\begin{enumerate}[label=(\roman*)]
  \item Cada robot conoce en todo momento su ubicación (posición y orientación).
  \item La comunicaciones son sin perdida y de rango infinito.
  \item El entorno a explorar es cerrado.
  \item Los robots son circulares e iguales entre sí.
  % \item El entorno es estático.
\end{enumerate}

Estas hipótesis tienen el motivo de simplificar algunos aspectos del
problema de exploración permitiendo que el trabajo se pueda enfocar en otros.

La hipótesis I resuelve trivialmente el problema de localización. La hipótesis
II simplifica la coordinación al no tener que considerarse en esta los posibles
problemas de comunicación que pueden haber de asignar robots a objetivos muy
distantes o con obstrucciones entre si. La hipótesis III es útil
principalmente para poder aplicar el criterio de parada que consiste en detener
la exploración al no tener más objetivos restantes (sección
\ref{sec:exploracion}). 

\section{Arquitectura}
La arquitectura se divide en dos partes robots y unidad central.  Cada una de
estas partes esta asociado a un hardware especifico, siendo los robots móviles
y la estación central estática. Los robots pueden ser uno o más mientras que la
estación central es única. Cada parte se compone de módulos los cuales cuales se
encargan de tareas específicas. 

En la figura \ref{fig:arquitectura} se resume la arquitectura en un diagrama en
el cual es posible ver los componentes, sus módulos dichos módulos, como se
distribuyen entre los componentes y una simplificación de las comunicaciones
que ocurren entre ellos.


\begin{figure}[H]
  \center
  \includegraphics[width=1\linewidth]{imagenes/arquitectura.png}
  \caption[Arquitectura de la solucion propuesta.]{Arquitectura de la solución propuesta. El modulo coloreado con azul es provisto por ROS. Los módulos no coloreados fueron  implementados en esta propuesta.}
  \label{fig:arquitectura}
\end{figure} 

En lo que resta de esta sección se comentará cada modulo, tanto sus tareas y como sus interacciones con el resto de los módulos.

\subsection{Move Base}
El modulo \emph{Move Base} consiste en una instancia del nodo ROS
\emph{move\_base} \cite{ROS-move_base} que provee una interfaz para configurar,
ejecutar y interactuar con el \emph{stack de navegación} de ROS
\cite{ROS-navigation}. 

El stack de navegación de ROS es un conjunto de nodos que tienen como propósito
que un robot pueda navegar el entorno hacia objetivos dentro del mismo. En la
figura \ref{fig:move_base} se muestra un diagrama que repesenta a los nodos que
componen al stack de navegación de ROS y sus interacciones.

\begin{figure}[H]
  \center
  \includegraphics[width=1\linewidth]{imagenes/move_base.png}
  \caption[Arquitectura del stack de navegación de ROS.]{Arquitectura del stack de navegación de ROS. Extraída de \cite{ROS-move_base}.}
  \label{fig:move_base}
\end{figure} 

Cuando se establece un objetivo de navegación este se trasmite al nodo
\emph{global\_planner} este se encarga de generar un plan de alto nivel
consistente de un numero de subobjetivos, que de seguirse en secuencia llevan
al robot al objetivo sin colisiones.

El camino generado por el \emph{global\_planner} es enviado al nodo
\emph{local\_planner} que se encarga de tomar el plan en alto nivel y
traducirlo a la secuencia las velocidades lineales y angulares que un robot
debe tener a lo largo del tiempo para seguir el global. A dicha secuencia de
velocidades se le conoce como plan local.

El stack de navegación permite utilizar distintas implementaciones de
\emph{global\_planner} y \emph{local\_planner}. En el trabajo desarrollado se
hace uso del \emph{global\_planner}\cite{ROS-global_planner} valga la
redundancia llamado \emph{global\_planner} y el \emph{local\_planner} llamado
\emph{teb\_local\_planner}\cite{ROS-teb_local_planner}.

Para generar sus planes tanto \emph{local\_planner} como \emph{global\_planner}
requieren de un mapa, de esto se encargan los nodos \emph{local\_costmap} (mapa
local) y \emph{global\_costmap} (mapa global) respectivamente. Ambos dos son
una instancia de una misma clase de nodo llamada \emph{costmap\_2d}
\cite{ROS-costmap_2d}, que dentro de sus funcionalidades esta la de de
construir una grilla de ocupación a partir de los datos sensoriales provistos
por los robots. Las principales diferencias entre el mapa global y el local son su
tamaño de celda (pequeño en el local y grande en el global), sus dimensiones
del mapa (el mapa global es el mapa completo mientras que el local es solo una
porción) y sus marcos de referencia (el mapa global suele estar fijo, el local se
centra en el robot).

El nodo \emph{recovery\_behaviors} permite ejecutar comportamientos de
recuperación de detectarse que el robot no esta avanzando de forma correcta al
objetivo. Para la solucion desarrollada solo se hace uso del comportamientos de
recuperación que consite en que el robot rote en el lugar.
%en el lugar y forzar que recalculen porciones del mapa.

% El \emph{global\_planner} hace uso de un mapa global, este mapa es provisto por 


% lograr esto cuando se establece un objetivo de navegación,


% de permitir que un robot pueda mover que a partir de información sobre la ubicación, sensores del robot, v 


\subsection{Combinador de mapas}
El modulo \emph{Combinador de mapas} es el encargado de mantener el mapa del entorno
explorado. Este recibe las actualizaciónes de los mapas globales que son
generados por el nodo \emph{global\_costmap} del stack de navegacion de cada
robot y las combina en un unico mapa que contenga toda la información
recopilada del entorno. Cuando el mapa combinado global se actualiza este
retrasmite lo actualizado a diversos componentes del sistema (ver figura
\ref{fig:arquitectura}) que utlizan el mapa del entorno explorado para llevar a
cabo alguna de sus tareas. 

\subsection{Controlador central}

El modulo \emph{Controlador central} lleva a cabo la identificacion de objetivos, es decir detectar en
el mapa actual los potenciales objetivos de exploracion. 

A su vez es el principal responsable de realizar la asignacion de objetivos.
Específicamente la asignacion de objetivos consiste en una subasta en la cual
este modulo actua como subastador. La subasta se puede resumir de la siguiente
manera, los objetivos de exploracion identificados son transmitidos desde el
controlador central a los robots los cuales valuan a dichos objetivos segun que
tan conveniente les es llegar a ellos. Los robots envian sus valuaciones a la
central la cual aplica una algorimo para determinar que objetivo le corresponde
a cada robot y posteriormente le informa a cada robot que objetivo le
corresponde.

% tiene el
% siguiente funciona en la cual  de objetivos consite en tomar los objetivos
% identificados y coordinar

% La prinicpal es la de llevar a cabo la identificación de tareas y ser el 

% e encarga de coordinar las subastas de segmentos, es decir, genera la
% información necesaria para esta, decide cuando comienza la subasta y cuando
% termina el plazo para ofertar, computa los resultados y se encarga de las
% comunicaciones necesarias para llevarla a cabo.

\subsection{Controlador de movimiento}
El modulo \emph{Contrador de movimiento} es como su nombre lo indica el modulo
que se encarga de controlar el movimiento del robot. Específicamente recibe
caminos compuesto por celdas de la grilla de ocupacion que en secuencia llevan
a un objetivo de exploracion, y se encarga de ir enviando objetivos de
navegacion al modulo \emph{Move Base} para que el camino sea ejecutado de forma
rapida evitando maniobras innecesarias.

Tambien lleva a cabo una capa superior de comportamientos de recuperacion
extendiendo los provistos por el modulo \emph{Move Base}.

Indica al \emph{Controlador del robot} si se completo el camino con exito, o
existe algun problema.

\subsection{Controlador del robot}
El \emph{Controlador del robot} es el modulo que se encarga de valuar los
objetivos cuando ocurre una subasta. A su vez se encarga de procesar las
asignaciones de objetivos determinadno el camino que lleva al objetivo y
enviandolo al modulo \emph{Controlador de movimiento}. 

Tambien es responsable por solicitar el inicio de una subasta al
\emph{Controlado central} cuando el \emph{Controlador de moviemiento} indica el
exito o el fracaso en seguir el camino asignado.

% Tambien pide la subasta.\todo{explicar mejor}

% \section{Ciclo de robot}

% \section{Ciclo de la central}
\section{Definiciones}
\subsection{Grillas de ocupacion}
En el contexto de este trabajo se utlizara las siguientes definiciones referentes a
grillas de ocupacion, introducidas en la seccion \ref{subsec:mapas}.

El conjunto $C\subseteq R^2$ esta conformado de los centros de cada celda de la
grilla de ocupacion. Las celdas se repreresentan segun sus centros y viceversa
sin ambigüedad, por lo tanto en lo que resta de este informe se usaran ambos
terminos de forma indistinta.

Se dice que cada celda $c\in C$ tiene asociada una probabilidad $P(c|m(1:k))$
de estar ocupada, donde $m(1:k)$ es el conjunto de medidas resultantes de algun
sensor desde el comienzo de la exploarcion.

La funcion $e : C \rightarrow E$ dado un centro de celda, devuelve uno de los
tres estados posibles $E=\{libre, ocupado, desconocido\}$ segun la probabilidad
asociada a $c$. En el contexto de este proyecto la funcion $e$ se define segun
(\ref{eq:estado}).
\begin{equation} 
  e(c)= 
  \left \{ 
    \begin{aligned}
       libre       &\ \ \ \text{ si}& P(c|m(1:k)) < 0.5 \\
       desconocido &\ \ \ \text{ si}& P(c|m(1:k)) = 0.5 \\
       ocupado     &\ \ \ \text{ si}& P(c|m(1:k)) > 0.5
    \end{aligned}
  \right .
  \label{eq:estado}
\end{equation}

La funcion $ady : C \rightarrow P(C)$ dada una celda devuelve el conjunto de
celdas adyacentes a la misma. La definicion de $ady$ utlizada en el contexto de
este proyecto se presenta en (\ref{eq:vecinos}) donde $n_1, n_2, ..., n_8$ se
corresponden a vecinos diagonales y horizontales de $c$ segun se muestran en la
figura \ref{fig:vecinos}.

\begin{equation} 
 ady(c)=\{n_i : 1\leq i \leq 8, n_i \in C\}
 \label{eq:vecinos}
\end{equation} 

\begin{figure}[H]
  \center
  \includegraphics[width=0.3\linewidth]{imagenes/vecinosSharp.png}
  \caption[Vecinos de una celda en una grilla de ocupación.]{Vecinos de una celda en una grilla de ocupación.}
  \label{fig:vecinos}
\end{figure} 

Notar que la relacion de adyacencia es simetrica por lo que $c_1 \in ady(c_2) \Rightarrow c_2 \in ady(c_1)$.
% This map is obtained from the occupancy probability grid by a simple clipping operation with a threshold of 0.5. The gray areas of the maximum-likelihood map correspond to cells that have not been sensed by the robot.

\subsection{Componentes conexas} \label{subsec:CompComp}
Una descomposicion en componentes conexas de un conjunto de
celdas $C$ es un conjunto $CC\in P(C)$ compuesto por $N$ conjuntos $C_i$ con
$i\in[1,N]$ tales que:
\begin{itemize}
  \item $\bigcup_{i=1}^{N}C_i = C$ 
  \item Para todo $i,j \in [1,N]$ $C_i\cap C_j = \emptyset$
  \item Para todo $i \in [1,N]$, para todo par $c_1,c_2 \in C_i$ se cumple que $c_1 \in ady(c_2)$.
  \item No existen $i,j \in [1,N]$ tales que existan $c_1 \in C_i$ y $c_2 \in C_j$ que cumplan con $c_1 \in ady(c_2)$ 
\end{itemize}

Un ejemplo de una descomposicion en componentes conexas se muestra en la figura \ref{fig:fronterasCompCon}.

\begin{figure}[H]
  \centering
  \subfloat[Las celdas pertenecientes a $C$ se marcan con azul.]{\includegraphics[clip=true, width=0.40\linewidth]{imagenes/compCon/a.png}}
  \qquad
  \subfloat[Cada componente conexa de $C$ se contornea con rojo.]{\includegraphics[clip=true, width=0.40\linewidth]{imagenes/compCon/b2.png}}

  \caption{Descompocicion en componentes conexas.}\label{fig:descCompCon}
\end{figure}

Es posible obtener las compnentes conexas de un conjunto cualquiera $C$ de
celdas con el algoritmo \ref{alg:compcon}

\begin{algorithm}[H]
\SetAlgoLined
  $CC := \emptyset$
  $pila :=$ Pila Vacia \\
  $i := 1$ \\
  $restantes := C$ \\
  \While{ $\neg restantes.vacia()$ } {
    $C_i := \emptyset $ \\
    $c :=$ elemento arbitrario de $Restantes$ \\

    % \tcp{DFS desde $c$ agregando las celdas visitadas a la componente conexa $C_i$}

    $C_i :=  C_i \cup \{c\}$ \\
    $restantes := restantes - \{c\}$ \\
    $pila.apilar(c)$ \\
    \While { $\neg pila.vacia()$ } {
      $c := pila.desapilar()$ \\
      \For{ $cA \in ady(c)$ } {
        \If{ $cA \in restantes$ } {
          $C_i :=  C_i \cup \{c\}$ \\
          $restantes := restantes - \{c\}$ \\
          $pila.apilar(c)$ \\
        }
      }
    }
    $CC := CC \cup C_i$ \\
    $i := i + 1$ \\
  }
  \Return $CC$ 

  \caption{Asignación de objetivos}
  \label{alg:compcon}
\end{algorithm}

Este algoritmo se resume en elegir una celda $c\in C$ que no este aun en una
componente conexa (linea 6), aplicar un \emph{depth-first search} (DFS)
partiendo $c$ agregado todas las celdas recorridas a una misma componente
conexa (lineas 7-19). Repetir dicho procedimiento hasta que todas las celdas
pertenezcan a alguna componente conexa (linea 4). Este algormitmo es analogo al
que esta presente en \cite{hopcroft1973algorithm}.

\section{Identificación de objetivos}
El problema de identificación de objetivos consiste en determinar los puntos
del espacio a los cuales es conveniente enviar robots para recolectar nueva
informacion sobre el entorno explorado. Estos puntos son los llamdos objetivos
de exploración. 
% En el contexto del trabajo desarrollado al utlizarse una grilla de ocupacion
% como mapa los 
% se hablara de celdas en lugar de puntos, existiendo una correspondencia entre
% cada celda y un unico punto en el espacio, su centro.

\subsection{Fronteras}
En \cite{yamauchi1998frontier} se propone que los lugares que permiten
recolectar la mayor cantidad de nueva informacion sobre el entorno son las
fronteras entre el espacio conocido y desconocido. Y que por lo tanto dichas
fornteras deben ser los objetivos de exploración.
Al utlizar una grilla de ocupacion como mapa, las fronteras se definen como las
celdas cuyo estado asociado es $libre$ y son adyacentes a una celda cuyo estado
asociado es $desconocido$ (figura \ref{fig:fronteras}).
Por lo tanto segun Yamauchi los objetivos de exploración seran las celdas
fronteras $F$ segun se definen en (\ref{eq:fronteras}).
\begin{equation} 
  F = \{ c \in C : e(c) = libre, \exists n \in ady(c), e(n) = desconocido  \}
  \label{eq:fronteras}
\end{equation}

\subsection{Fronteras simplificadas según K-Means}
En \cite{amorin2019novel} se argumenta que tratar todas las celdas fronteras
como objetivos de exploración diferentes podría ser computacionalmente
prohibitivo. Por lo tanto, para reducir el costo computacional, se intenta
reducir los objetivos de exploración a las celdas frontera mas representativas,
a las cuales se denominaran como fronteras significativas.

Para determinar las fronteras significativas, primero, las celdas fronteras $F$
se descomponen en sus componentes conexas $\mli{FC}=\{F_1,F_2,...F_N\}$
(seccion \ref{subsec:CompComp}), un ejemplo de este tipo de descomposicion se
puede ver en la figura \ref{fig:fronterasCompCon}.

Luego se determinan las fronteras significativas $\mli{FS}_i$ de cada
componente conexa $F_i\in \mli{FC}$. Esto se hace agrupando las fronteras de
$F_i$ con el algoritmo K-Means \cite{macqueen1967some}, y determinando una
frontera significativa por cada una de las $k$ agrupaciones, la
frontera mas cercana de $F_i$ al centroide de la agrupacion (una arbitraria de
las mas cercanas en el caso de que exista mas de una). Un ejemplo de las
fronteras significativas  $\mli{FS} = \bigcup_{i=1}^N \mli{FS_i}$ obtenidas con
este metodo se muestra en la figura \ref{fig:fronterasSig}.

El $k$ utilizado para ejecutar K-Means es el minimo que logra que para toda
frontera $f\in F_i$ existe $\mli{fs} \in FS_i$ tal que $d_{\mli{fs}}(f) <
rango$ siendo $rango$ el rango de los sensores del robot. Parafraseando, el
conjunto de fronteras significativas $\mli{FS}_i \subset F_i$ cumple con que
cada frontera esta dentro del rango del sensado de alguna frontera
significativa, cuando esto se cumple se dice que $\mli{FS}_i$ cubre a $F_i$, o
que $FS_i$ logra el cubrimiento. En la figura \ref{fig:fronterasSigCub} se
puede ver como las fronteras significativas obtenidas $FS$ logran el
cubrimiento, ya que todas los centros de las fronteras $F$ estan contenidos en
las circunferencias de radio $rango$ centradas en las frontera significativa
$FS$.

Para encontrar el minimo $k$ con las que se logra un $\mli{FS}_i$ que cubra a
$F_i$, se parte con $k=1$, si el resultado no logra cubrir incrementa $k$ y se
repite el proceso.


\begin{figure}[H]
  \centering
  \subfloat[Se identifican las frotneras,  marcadas con amarillo.]{\includegraphics[clip=true, width=0.40\linewidth]{imagenes/fronterasSig/a.png}\label{fig:fronteras}}
  \qquad
  \subfloat[Descompocicion de las fronteras en componentes conexas, cada componente conexa se indica con un color distinto.]{\includegraphics[clip=true, width=0.40\linewidth]{imagenes/fronterasSig/b.png}\label{fig:fronterasCompCon}}
  \qquad
  \subfloat[Frontera significativas (indicadas con verde) de cada componente conexa.]{\includegraphics[clip=true, width=0.40\linewidth]{imagenes/fronterasSig/c.png}\label{fig:fronterasSig}}
  \qquad
  \subfloat[Se logra el cubrimiento con un rango igual a 4 largos de celda.]{\includegraphics[clip=true, width=0.40\linewidth]{imagenes/fronterasSig/d.png}\label{fig:fronterasSigCub}}

  \caption[Proceso de simplificacion de froteras según K-Means.]{Proceso de simplificacion de froteras según K-Means. Cada figura corresponde a una etapa distinta para un mismo entorno parcialmente explorado, representado con una grilla, donde las celdas blancas son libres, las negras ocupadas, y para las grises se desconoce su estado. Basada en figuras de \cite{Amorin2019}.}\label{fig:ejemploFrontSig}
\end{figure}

% En la seccion anterior se presento un metodo que soluciona el siguiente
% problema. Dado un conjunto de  la descomposicion en componentes conexas de
% $F$, $\mli{FC}=\{F_1,F_2,...F_N\}$ se obteniene como salida el conjunto
% $\mli{FS} = \bigcup_{i=1}^N \mli{FS_i}$ que cumple con la restriccion de que
% para todo $i \in [1,N]$ $\mli{FS}_i$ cubre a $F_i$.

El problema descrito hasta el momento se puede resumir en el de  dado un
conjunto de fornteras $F$, obtener un conjunto de fornteras significativas
$\mli{FS}$ que cumplen con la restriccion de que $\mli{FS}$ cubre a $F$.
Recordando que el proposito de usar $\mli{FS}$ como objetivos de exploracion en
lugar de usar $F$ es reducir los objetivos de exploracion entoces es natural
pensar que la soluciones optimas reducen al minimo el $\mli{FS}$ resultante,
mientras mantienen la restriccion de cubrimiento.

% Analizando la restriccion de cubrimiento, se puede ver que un indicador de que
% una solucion es suboptima es que varias celdas $\mli{FS}$ se concentren,
% solapandose las circunferencias de radio $rango$ centradas en ellas. Por
% ejemplo 

Dado esto es posible ver que en el ejemplo presentado en
\ref{fig:ejemploFSKMMal} el resultado obtenido por el metodo presentado en esta
seccion no es optimo ya que existen fronteras significativas innecesarias para
el cubrimiento. 

\begin{figure}[H]
  \centering
  \subfloat[Fronteras significativas obtenidas segun el metodo basado en K-Means, con $rango = 5.6$.]{\includegraphics[clip=true, width=0.40\linewidth]{imagenes/fronterasigKMMal/caso1/a_sin_circ.png}}
  \qquad
  \subfloat[Dos de las fronteras significativas de la parte inferior derecha de (a) no son necesarias para lograr el cubrimiento.]{\includegraphics[clip=true, width=0.40\linewidth]{imagenes/fronterasigKMMal/caso1/b.png}}

  \caption[Simplificacion de fronteras suboptima resultante del metodo basado en K-Means.]{Simplificacion de froteras suboptima resultante del metodo basado en K-Means. Extraída de implementacion desarrollada\footnotemark.}\label{fig:ejemploFSKMMal}
\end{figure}
\footnotetext{Podria indicar el bag y el seg}

Resultados suboptimos similares se obtienen de forma consistente %al aplicarse la simplficacion 
sobre componentes conexas con forma serpenteante \todo{no se
  si este termino se entiende, me es dificil explicarlo bien, con forma de S?},
  asimetricas y con un largo mayor a $rango*8$ 
\todo[inline]{se entiende la idea del largo aplicada a esto? Creo que puede
quedar claro mirando la foto pero tengo mis dudas. La idea en realidad seria
decir que la solucion no es lo suficientemente simple, por ejemplo si con 1
sola frontera sig ya se cubre todo entonces no va haber problema sin importar
que tan serpenteante o asimetrica sea. Pero se me ocurre que por el largo puede quedar mas claro}
, empeorando (mayor cantidad de fornteras significativas
innecesarias para el cubrimiento) a medida que las componentes conexas de
fronteras son mas largas y las curvas son mas intrincadas.

% (comentarlos, distribuciones desparejas, acumulacion, no
% equidistantes) 

% Una explicacion posible a este comportamiento es que la distibucion de centroides en K-Means 

% Algo que se repite en estas situaciones es que suele haber zonas, en donde las
% fornteras significativas se acumulan, y zonas en las que estan muy dispersas
% (casi a $rango$ de distancia una de la otra, el maximo). Esto lleva a pensar que K-Means se tiende a ubicar concentrar los centroides en una zona,

Esto se presume que se debe principalmente a dos factores relacionados a
K-Means. (i) K-Means no considera la restriccion de cubrimiento para generar sus
resultados. La restriccion se fuerza ejecutando K-Means con el minimo $k$
(obtenido con prueba y error) segun el cual las fronteras significativas
resultantes logran el cubrimiento. (ii) Los centroides resultantes de K-Means
no son fronteras. Estos se deben traducir a fronteras posteriormente.

\todo{Hay una arbitrariedad asociada a k-means tambien lo cual puede ser criticado tambien, aunque deberia estudiar mejor el tema, quizas no criticarlo aca pero destacar que el otro metodo es menos opaco en como elige las front sig}
% Esto es la clase de pe la idea de obtener fornteras significativas es reducir el numero
% de objetivos de exploracion,

% El metodo basado en K-Means aunque funciona bien al aplicase en componentes conexas pequeñas, 

% El metodo descrito en la seccion resulta en un conjunto de fronteras
% significativas que cubren a las fronteras, el problema que se detecto
% experimentalmente es que en ciertos casos el resultado  la discribucion de las
% fronteras significativas es mala, se concentran mucho en ciertas porciones y se alejan 

\subsection{Fronteras simplificadas según su geometría}
Con esto en mente se desarrolla un metodo novedoso que considera los dos puntos
destacados anteriormente. (i) Tomando en cuenta el cubrimiento y su
optimizacion como parte fundamental del algorimo. (ii) Dando directamente
fronteras como resultado.

El algorimo al igual que el descrito en la seccion anterior comienza
descomponiendo a las fronteras $F$ en sus componentes conexas
$\mli{FC}=\{F_1,F_2,...F_N\}$ para luego obtener las fronteras significativas
$\mli{FS}_i$ para cada componente $F_i$, siendo el conjunto total de fronteras
significativas $FS$ la union $\bigcup^N_{i=0} \mli{FS}_i$

Para obtener las fronteras significativas de $F_i$ el algorimo parte mantiene
las fronteras sigficativas determinadas $\mli{FS}_i := \emptyset$ y el conjunto
todas las fronteras que resta cubrir $\mli{UF} := F_i$ (siglas del ingles
\emph{uncovered frontiers}), y a grandes rasgos consiste en:
\begin{enumerate}
  \item Elegir una frontera de $\mli{UF}$ como frontera significativa $\mli{fs}$.

  \item Actualizar $\mli{FS}$ agregando a $\mli{fs}$:

    $\mli{FS} := \mli{FS} \in \{\mli{fs}\}$

  \item Actualizar $\mli{UF}$ removiendo todas las fronteras cubiertas por $\mli{fs}$:

    $\mli{UF} := \mli{UF} - \{ f\in F : d_{\mli{fs}}(f) < rango\}$

  \item Si $\mli{UF} \neq \emptyset$ volver a 1. de lo contrario devolver $FS_i$.
\end{enumerate}

% De los pasos presentados el primero es el principal y tambien el mas complejo
% del algorimo.

Los pasos del 2 al 4 no presentan ambigüedad, siendo el primer paso en el que
resta aclarar, especificamente resta aclarar el criterio con el que se elige la
frontera significativa. La eleccion en un principio podria ser aleatoria y el
algormitmo daria resultados correctos, pero esto dejaria a la suerte la
optimalidad. La idea seria elegir una frontera significativa que cubra la mayor
cantidad de frotneras evitando cubrir nuevametne fronteras que ya sean
cubiertas por otra frotntera significativa.


DESCRIBIR algo a detalle, fotitos, etc.

% EL algorimo se basa en la idea de que una buena distribucion de fronteras
% significativas deberia mantener en su mayor parte una distancia de $rango*2$
% entre cada frontera significativa, ya que esta es la distancia maxima que se
% puede tener para asegurar qu se cumpla el cubrimiento. 


\section{Asignación de objetivos}
\todo{FEDE: Wurm aparentemente no considera que el numero de robots asigandos a un segmento debe ser menor que el numero de fronteras que tiene ya que no tiene sentido asignar a un robot  a un segmento si eseete no tiene objetivos disponibles. Habria que ver bien como funciona el metodo hungaro, pero creo que es una asignacion robot-segmento que no considera otra cosa que el costo, por lo tanto el num de fronteras de un segmento no se estaria considerando}

\subsection{Contruccion del GVD}

\subsection{Segmentacion}


\section{Planificación}

\section{Construcción cooperativa del mapa}


% \section{mejora sobre wurm}




